1.Создайте пустой репозиторий git с помощью команды git init . Также ознакомьтесь с опцией --bare и собственно голыми репо.
2.Создадим новый файл командой touch README.md .
3.Чтобы изменить существующий файл, мы будем использовать текстовый редактор VIM

 ![](https://github.com/Kirill-mi/MJC_Git/blob/git_task/png1.png)
 
4. Чтобы проверить прогресс, введите команду git status .
5.Чтобы отслеживать readme, вы можете использовать git add. команда.

 ![](https://github.com/Kirill-mi/MJC_Git/blob/git_task/png2.png)
 
6. Пришло время внести изменения. Для создания коммита используйте команду git commit -m «created readme»

 ![](https://github.com/Kirill-mi/MJC_Git/blob/git_task/png3.png)
 
7.Мы собираемся создать новую ветку под названием develop, которая будет содержать все функции, над которыми вы сейчас работаете.
 Чтобы создать новую ветку, выполните команду git checkout -b develop . Это создаст новую ветку из текущего (главного). 
Создайте ветку git_task из develop и git_0 ветку из git_task . Вы можете использовать команду git show-branch для одновременного просмотра всех веток.
 Ветвь, с которой вы сейчас работаете, отмечена символом * .

 ![](https://github.com/Kirill-mi/MJC_Git/blob/git_task/png4.png)

8. Теперь мы добавим некоторые изменения в README.md с помощью vim , проверим статус, изменим этапы с помощью команды git add README.md ,
 зафиксируем изменения, проверим результат (статус), затем выполнили проверку в ветке git_task (с помощью команды git checkout git_task ) 
и объединим изменяется из ветки git_0 с помощью команды git merge git_0 --no-ff . Найдите время, чтобы прочитать о слиянии и опции no-ff .
 Обычно это поведение слияния запросов на вытягивание по умолчанию, поэтому вы будете работать с ним ежедневно
 
 ![](https://github.com/Kirill-mi/MJC_Git/blob/git_task/png5.png)
 
9.Теперь повторите процесс слияния, чтобы передать ваш коммит в ветку master ( конечно, путем разработки ). Когда вы закончите, вы можете 
использовать эту команду git log --all --graph --decorate --oneline --simplify-by-decoration или эту команду git log --graph --oneline –all .
 Эти команды были найдены в stackoverflow как ответ на вопрос о просмотре истории git в виде дерева. Это не лучшее решение, но для наших нужд 
его более чем достаточно. Результат должен выглядеть примерно так: Из этого изображения вы можете видеть, что HEAD в настоящее время просматривает 
последнюю фиксацию мастера. 

![](https://github.com/Kirill-mi/MJC_Git/blob/git_task/png6.png)